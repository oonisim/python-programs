def pack_images_as_rgb_from_directory(
        path_to_source: str,
        pattern: Union[str, None],
        skip_image_error: bool = True
) -> Tuple[Union[np.ndarray], List[str]]:
    """Pack multiple color images as RGB into one np array
    The image data in memory MUST be in RGB. OpenCV imread load the image into memory as BGR.

    Args:
        path_to_source: source directory
        pattern: Pathlib glob pattern to filter files to process or None
        skip_image_error: continue upon image processing errors
    Returns: (packed images in array of shape (N, height, width, depth), list of packed file names)
    """
    name = "pack_images_as_rgb_from_directory()"
    assert is_dir(path_to_source), f"invalid source [{path_to_source}]."
    result: Union[np.ndarray, None] = None

    processed: List[str] = list()
    package: List[np.ndarray] = list()
    try:
        # --------------------------------------------------------------------------------
        # List and process files
        # --------------------------------------------------------------------------------
        filenames: List[str] = list_files_in_directory(
            path=path_to_source, pattern=pattern
        )
        if len(filenames) == 0:
            _logger.warning("%s: no file to pack in the directory [%s]", name, path_to_source)
        else:
            for _filename in filenames:
                source: str = os.sep.join([path_to_source, _filename])
                resized: np.ndarray

                # --------------------------------------------------------------------------------
                # Load image to pack
                # --------------------------------------------------------------------------------
                try:
                    # image is loaded into memory as BGR
                    img: np.ndarray = get_image(path=source)
                    _h, _w, _d = get_image_dimensions(image=img)
                    if _d is None:  # Grey scale image
                        _logger.info("%s: skipping grey scale image [%s]...", name, _filename)
                        continue

                except ValueError as e:
                    _logger.info("%s: cannot handle and skip [%s]...", name, source)
                    if skip_image_error:
                        continue
                    else:
                        raise e

                # Make sure to convert BGR to RGB
                package.append(convert_bgr_to_rgb(image=img))
                processed.append(_filename)

            # END for loop
            result = np.array(package)
            del package
            assert result.ndim == 4

    except (OSError, RuntimeError) as e:
        _logger.error("%s: failed due to [%s]", name, e)
        raise e

    return result, processed


def resize_and_save_images(
        path_to_source: str,
        pattern: Union[str, None],
        height: int,
        width: int,
        path_to_destination: str,
        skip_image_error: bool = True
) -> Tuple[int, int]:
    """Resize the images in the source directory and save them to the destination.
    Args:
        path_to_source: source directory
        pattern: Pathlib glob pattern to filter files to process or None
        height: height to resize to
        width: width to resize to
        path_to_destination: destination directory
        skip_image_error: continue upon image processing errors
    Returns: (number of images processed, number of image not processed)
    Raises:
         RuntimeError: for any filesystem errors
         ValueError: for image not able to process
    """
    name = "resize_and_save_images()"
    assert is_dir(path_to_source), f"invalid source [{path_to_source}]."
    assert not is_file(path_to_destination), \
        f"destination [{path_to_destination}] is an existing file."
    assert height > 0 and width > 0, f"invalid height [{height}] or width [{width}]"

    processed: int = 0
    skipped: int = 0
    try:
        # --------------------------------------------------------------------------------
        # Setup: Create destination directory if not exist.
        # --------------------------------------------------------------------------------
        if not is_dir(path_to_destination):
            mkdir(path=path_to_destination)

        # --------------------------------------------------------------------------------
        # List and process files
        # --------------------------------------------------------------------------------
        filenames: List[str] = list_files_in_directory(
            path=path_to_source, pattern=pattern
        )
        if len(filenames) == 0:
            _logger.warning("%s: no file to resize in the directory [%s]", name, path_to_source)
        else:
            for _filename in filenames:
                source: str = os.sep.join([path_to_source, _filename])
                destination: str = os.sep.join([path_to_destination, _filename])
                resized: np.ndarray

                # --------------------------------------------------------------------------------
                # Load image to resize
                # --------------------------------------------------------------------------------
                try:
                    img: np.ndarray = get_image(path=source)
                    _h, _w, _d = get_image_dimensions(image=img)
                    if _d is None:  # Grey scale image
                        _logger.info("%s: skipping grey scale image [%s]...", name, _filename)
                        skipped += 1
                        continue

                except ValueError as e:
                    _logger.info("%s: cannot handle and skip [%s]...", name, source)
                    if skip_image_error:
                        skipped += 1
                        continue
                    else:
                        raise e

                if _h == height and _w == width:
                    # no change, do nothing
                    resized = img
                else:
                    # --------------------------------------------------------------------------------
                    # Interpolation option depending on if the operation is shrink or enlarge
                    # --------------------------------------------------------------------------------
                    if _h * _w > width * height:
                        interpolation: int = cv.INTER_AREA
                    else:
                        interpolation: int = cv.INTER_LINEAR

                    logging.debug("%s: resizing file [%s] to %s ...", name, source, (width, height))
                    resized = resize_image(
                        image=img, width=width, height=height, interpolation=interpolation
                    )

                processed += 1
                del img

                _logger.debug("%s: saving image to [%s]", name, destination)
                save_image(path=destination, image=resized)
            # End of for loop

    except (OSError, RuntimeError) as e:
        _logger.error("%s: failed due to [%s]", name, e)
        raise e

    return processed, skipped